% -*- mode:latex; mode:flyspell -*-
\documentclass[10pt, conference, compsocconf]{IEEEtran}

% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  \usepackage{color}
  \usepackage{epstopdf}
  %\usepackage[update]{eps2pdf}
  %\usepackage[pdf]{pstricks}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi


\usepackage{bibspacing}
\setlength{\bibspacing}{\baselineskip}

% *** MATH PACKAGES ***
%
\usepackage{multirow}
\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
% \hyphenation{op-tical net-works semi-conduc-tor}

\usepackage{xspace}
\usepackage{bm}
\newcommand{\numtplgynodes}{\ensuremath{|V_r|}\xspace}
\newcommand{\gpunum}{\ensuremath{N_G}\xspace}
\newcommand{\veclenset}{\ensuremath{\bm{V}}\xspace}
\newcommand{\mipsset}{\ensuremath{\bm{M}}\xspace}
\newcommand{\corenumset}{\ensuremath{\bm{C}}\xspace}
\newcommand{\expt}{\ensuremath{\bm{E}}\xspace}
\newcommand{\ul}{\underline}
\newcommand{\noname}{The NoNamer\xspace}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{A framework for design space exploration for HPC architectures}


% author names and affiliations
% use a multiple column layout for up to two different
% affiliations

\author{\IEEEauthorblockN{Authors Name/s per 1st Affiliation (Author)}
\IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
line 2: name of organization, acronyms acceptable\\
line 3: City, Country\\
line 4: Email: name@xyz.com}
\and
\IEEEauthorblockN{Authors Name/s per 2nd Affiliation (Author)}
\IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
line 2: name of organization, acronyms acceptable\\
line 3: City, Country\\
line 4: Email: name@xyz.com}
}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
%
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3},
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}

  In this article we provide a framework for exploiting parallelism onto
  heterogeneous HPC architectures. Given a HPC cluster with varying
  compute units, communication constraints and topology, our framework
  can be utilized for partitioning applications exhibiting task and data
  parallelism resulting in increased throughput. Our framework can also
  be used by designers at an early design stage to explore the type of
  compute units needed and the topology that would be suited for a given
  application, thereby reducing costs and power requirements. The
  challenge lies in the fact that heterogeneous compute clusters consist
  of processing elements exhibiting different compute speeds, vector
  lengths, and communication bandwidths, which all need to be considered
  when partitioning the application and associated data. We tackle this
  problem using a staged graph partitioning framework. Our experiments
  show orders of magnitude speedup for applications. Furthermore our
  framework finishes within seconds even when simulating 100's of
  processing elements, which makes our architecture suitable for
  exploring parallelism potential off line or on line.

  % In this paper we solve the problem of partitioning applications with a
  % mixture of both: task-parallel and data-parallel parts onto
  % heterogeneous compute clusters. The challenge lies in the utilization
  % of vector and non-vector processing elements, while accounting for
  % varying communication latencies and bandwidths. We propose a graph
  % partitioning heuristic, which clusters a heterogeneous topology into a
  % homogeneous one and then partitions the applications onto the
  % resultant cluster in stages. Our experiments show that our approach is
  % results in X\% better application run-times, while being fast making
  % it suitable as a compilation time technique.

\end{abstract}

\begin{IEEEkeywords}
  Graph partitioning, vectorization, data parallelism, heterogeneous
  architectures, clusters.
\end{IEEEkeywords}


% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\input{introduction}


\section{Preliminaries}
\label{sec:preliminaries}

First of all, in this section, we present a formal description of the
problem along with the notations used.

\subsection{Notations}

We refer to our application graph, as a \textit{Static Task Graph} (STG)
defined formally as a weighted directed graph: $G_t(V_t, E_t)$, where
$V_t$ is the set of all tasks in the application graph and $E_t$
represents the communication between these tasks. The system resources
are represented by a weighted undirected graph $G_r(V_r, E_r)$ where
$V_r$ represents a set of processing elements which can have different
processing capabilities. Each vertex in the task graph, $t_i \in V_t$ is
referred to as tasks and each vertex in the resource graph, $r_i \in
V_r$ is referred to as processing element (PE). % We use $N_T$ to denote
% the total number of tasks in the task graph and $N_R$ to denote the
% total number of processing elements. By our definition of previous
% notations, it follows that $N_T = |V_t|$ and $N_R = |V_r|$.

\subsection{Problem Definition}

Given a graph $G_t(V_t, E_t)$, each vertex in the task graph, $t_i \in
V_t$ has a set of associated requirements represented by $T^{i}_{j}$
where $j=0...n$ with $n$ being the number of requirements for the task
node. These requirements represent the computational requirement of the
kernel. Consider the task graph in Figure~\ref{fig:1} for the running
Jacobi example. The \texttt{boxed} statements give the number of
instructions and the vector count requirements ($T^i_0\ \mathrm{and}\
T^i_1$). The communication edges ($(t_i, t_j) \in E_t$) between
data-stores (\texttt{boxed} statements without the constraints in
Figure~\ref{fig:1}) and the execution statements represent the amount of
data that needs to be transfered from the store and its utilization at
the statement level. Every communication link is weighted with the
amount of data that has to be transferred denoted by $e^c, \forall E_t
\in (V_t \times V_t)$ The task graphs are generated directly from the
program by our compiler. More information about the generation of the
task graphs is provided later in Section~\ref{sec:build-appl-graph}.

% From the perspective of the running example, constraint 0 of the first
% statement ($3$), represented by $T^{1}_{c0}$ denotes ----Avinash add
% some text here referring to the running jacobi example please----. Each
% edge $(t_i, t_j) \in E_t$ corresponds to the amount of data that has to
% be transferred from task $t_i$ to task $t_j$.

Similarly we have a resource graph $G_r(V_r, E_r)$ where each vertex
denotes a processing element. It consists of a set of vertices $V_r =
\{r_1, r_2, ... , r_n\}$ and a set of edges $E_r$. Each processing
element $r_i \in V_r$ has a set of decorations, that represent the
computational capabilities of the processing elements, represented by
$R^{i}_{j}$ where $j=0...n$ with $n$ being the number of constratins for
the resource node. For some resource graph shown in Figure~\ref{fig:res}
(level 0), which has $|V_r|$ nodes and 2 capabilities. For each node,
capability 1 ($R^i_0$) represents the frequency of the PE or how many
scalar instructions the PE can perform in one second (the
\textit{Million Instructions Per Second} (MIPS) count). Capability 2
($R^i_1$) denotes the maximum number of parallel vector operations it
can perform (the vector length). Each edge $e \in E_r$ has a weight
which represents the latency/bandwidth between two PEs $r_i$ and $r_j$
which is denoted by $E^c, \forall E_r \in (V_r \times V_r)$.

% While generating the resource graph, we might have to contract edges(becaus we
% contract nodes). Contracting an edge $e=\{i,j\}$ means to replace vertices $i$ and
% $j$ by a new vertex $k$ such that $R^k_0 = R^i_0 + R^j_0$ and $R^k_1 = R^i_1 +
% R^j_1$. All edges of the form $\{i,x\}$ and $\{j,x\}$ for $x \in V_r$ are replaced
% by $\{k,x\}$. If both edges $\{i,x\}$ and $\{j,x\}$ exist, we form the new edge weight
% as defined by $E^{\{w,x\}} = E^{\{i,x\}} + E^{\{j,x\}}$ More information about the
% generation about the generation of the resource graphs is provided later in
% Section~\ref{sec:gener-reso-graph}.

The problem at hand is to effectively map the said task graph $G_t$ onto
given resource graph $G_r$. This problem is known to be
NP-Hard~\cite{vsar89}. % This immediately implicates that we have to look
% for heuristic solutions.

To decide if a mapping is effective enough or not, we need an objective
function that defines how good a mapping of tasks onto resources
is. This is denoted by our cost function. We adapt the cost function
used by numerous other papers~\cite{ssan05,ajai04,dajw12} for our setup.
Given some application node $i \in V_t$ mapped to some resource $j \in
V_r$, the latency for that node is computed as: $((T^i_1/R^j_1\times
T^i_0)/R^j_0) + (e^d/E^c) | d = (i,k), k \neq i, \forall k \in V_t, c =
(j,l), l \neq j, \forall l \in V_r $. In this formulation for some task
$i$ being mapped onto some resource $j$, we first calculate the number
of vectorized instructions that can be executed in parallel (by dividing
required vector length by the vector capacity of $j$ represented by
$R^j_1$). We then multiply this number by the number of iterative
(non-vectorized) instructions required to get the total number of
instructions to be performed by that task-graph node. Once we have this
number we calculate latency of execution of this task-graph node $i$ on
this resource $j$ by dividing it with the MIPS value of the resource
denoted by $R^j_0$. Calculation of the communication latency is rather
simple, we divide the number of bits required to be transferred by the
bandwidth of the shortest path.

Given the task-graph and the resource-graph, let $\zeta$ be all possible
mappings of the application on the resource-graph. For a particular
mapping $\mathcal{M}$ defined as $\zeta_\mathcal{M}$ on some resource $s
\in V_r$ the mapping latency is defined as:

\begin{equation}
  \begin{array}{c}
    Latency^{\zeta_\mathcal{M}}_s = comp^{\zeta_\mathcal{M}}_s +
comm^{\zeta_\mathcal{M}}_s\\
	\\comp^{\zeta_\mathcal{M}}_s = 
    \sum_{\forall i \in V_t \wedge
      \zeta_\mathcal{M} = s} ((T^i_1/R^s_1\times T^i_0)/R^c_0)\\
    \\comm^{\zeta_\mathcal{M}}_s =
    \sum_{\forall i \in V_t \wedge
      \zeta_\mathcal{M} = s} e^d / E^c\\ 
    \\s.t., d = (i,k), k \neq i, \forall k
    \in V_t \wedge\  c = (s,l), l \neq s, \forall l \in V_r
  \end{array}
  \label{eq:1}
\end{equation}

Finally, the complete application latency can then be defined as: 
\begin{equation}
  \label{eq:2}
  Latency^{\zeta_\mathcal{M}} = max_{s}
  ({Latency^{\zeta_\mathcal{M}}_s}), \forall s \in V_t
\end{equation}

The objective of our framework is to find a mapping $\zeta_\mathcal{M}$
that minimizes the total application latency as described in
Equation~(\ref{eq:2}).

% \subsection{Key Contributions}
% Our key contributions in the article are as follows:
% \begin{itemize}
% \item A novel way for compiler writers and software programmers to gauge
%   the potential performance of their programs on any given architecture.
% \item A framework that allows topology designers to efficaciously
%   explore the design space to determine the type of underlying
%   architecture that would suit a given application.
% \item A new heuristic based framework that exploits task and data
%   parallelism exhibited by applications for mapping them onto
%   heterogeneous HPC architectures.
% \item Along with mapping application-tasks onto resource nodes, the
%   framework also allocates data-stores being utilized by the different
%   application-tasks.
% \item A rigorous experimental setup to analyse the effectiveness of our
%   framework.
% \end{itemize}

\section{Our framework}
\label{sec:our-framework}

In this section we describe our heuristic algorithm. There are three
important concepts that need description. First, we describe how we
extract fine grained parallelism from the application into the task
graph. Next, we describe how the topology clusters are formed from the
resource graphs accounting for communication and heterogeneity of the
topology. Finally, we describe how the mapping is performed.

\input{task_graph}

\input{resource_graph}

\input{implementation}

\input{experiments}

\input{related_work}

\section{Conclusion}
\label{sec:conclusion}

In this paper we have described a novel staged graph based partitioning
technique to partition and schedule applications onto heterogeneous
execution architectures. Our framework can be utilized by designers to
quickly gauge the type of underlying architecture that is best suited to
run a given application. Moreover, our framework considers both task and
data parallelism, which allows the application writers to design and
tune their applications to extract parallelism. We also consider
communication along application and underlying architecture edges, which
when combined with the task and data parallelism gives a better estimate
of the application latency than the currently described research
literature targeting similar problems.

We have tested our framework on a subset of the many high performance
computing applications currently in use in the industry with great
success. Our framework clearly shows that utilizing all the available
processing elements in the underlying architecture is not a good
solution when heterogeneity is in play. We have found that for most
applications, given a extremely heterogeneous topology, vector strip
size and correct placement of data plays and important role. Imbalanced
partitioning not only gives good application latencies, but also reduced
power consumption.

% use section* for acknowledgment
% \section*{Acknowledgment}


% The authors would like to thank...
% more thanks here


% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)

\scriptsize{
\bibliographystyle{IEEEtran}
% \bibliography{latex8}
\bibliography{/Users/amal029/Dropbox/BIBLIOGRAPHY_DATABASE/main_bib.bib}
}

% that's all folks
\end{document}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
